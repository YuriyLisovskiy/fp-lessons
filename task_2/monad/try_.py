# Try monad allows to build a sequences of functions
# including the ones which can throw an exceptions.
# In this case the generated exception will be handled
# automatically, interrupts calculations and will be
# available in 'recover' method, for example, for
# printing it or calling some other function.

from abc import ABC, abstractmethod


# Base Try abstract class.
class Try(ABC):

	# Executes @func and returns Successful instance with @func result.
	# If @func throws an exception, returns Failure instance with
	#   generated exception.
	@staticmethod
	def of_failable(func):
		assert func is not None
		try:
			return Try.successful(func())
		except Exception as exc:
			return Try.failure(exc)

	@abstractmethod
	def map(self, func):
		pass

	@abstractmethod
	def flat_map(self, func):
		pass

	@abstractmethod
	def recover(self, func):
		pass

	@abstractmethod
	def get_or_else(self, default):
		pass

	@abstractmethod
	def get(self):
		pass

	# Initializes Successful with given value.
	@staticmethod
	def successful(value):
		return Successful(value)

	# Initializes Successful with given exception object.
	@staticmethod
	def failure(exc):
		return Failure(exc)


# Represents success result of failable function call.
class Successful(Try):

	def __init__(self, value):
		self.value = value

	# Applies @func to value it holds.
	# Returns Success with result value, or Failure with
	#   an exception generated by @func.
	# @func must return non-Try value.
	def map(self, func):
		return Try.of_failable(lambda: func(self.value))

	# Applies @func to value it holds.
	# Returns Success with result value, or Failure with
	#   an exception generated by @func.
	# @func must return Try instance value.
	def flat_map(self, func):
		assert func is not None
		try:
			return func(self.value)
		except Exception as exc:
			return Try.failure(exc)

	# Always returns the value which Success holds.
	# @func accepts one parameter witch is an Exception or
	#   derivative class instance.
	def recover(self, func):
		assert func is not None
		return self.value

	# Always returns the value which Success holds.
	def get_or_else(self, default):
		return self.value

	# Always returns the value which Success holds.
	def get(self):
		return self.value


# Represents failure of failable function call.
# Holds the generated exception instance.
class Failure(Try):

	def __init__(self, exception):
		assert isinstance(exception, Exception)
		self.exception = exception

	# Passes an exception to the next function.
	def map(self, func):
		assert func is not None
		return Try.failure(self.exception)

	# Passes an exception to the next function.
	def flat_map(self, func):
		return self.map(func)

	# Used for recovering after the exception was thrown,
	#   for example, to print an exception.
	# @func accepts one parameter witch is an Exception or
	#   derivative class instance.
	def recover(self, func):
		assert func is not None
		return func(self.exception)

	# Always returns passed default value.
	def get_or_else(self, default):
		return default

	# If this method is called, Failure will raise
	#   an exception it holds.
	def get(self):
		raise self.exception
